<?php

require_once FLEXIONS_MODULES_DIR . '/Bartleby/templates/Requires.php';
require_once FLEXIONS_MODULES_DIR . 'Languages/FlexionsSwiftLang.php';

/* @var $f Flexed */
/* @var $d ProjectRepresentation */
/* @var $project ProjectRepresentation */
/* @var $action ActionRepresentation*/
/* @var $entity EntityRepresentation */

if (isset ( $f )) {
    // We determine the file name.
    $f->fileName = 'BaseDocument.swift';
    // And its package.
    $f->package = 'iOS/swift/';
}

$project=$d;// It is a project template

//Collection controllers are related to actions.

function _actionsShouldBeSupportedForEntity(ProjectRepresentation $project, EntityRepresentation $entity,$excludeActionsWith){
    $exclusion = array();
    $exclusionName = str_replace($project->classPrefix, '', $entity->name);
    if (isset($excludeActionsWith)) {
        $exclusion = $excludeActionsWith;
    }
    foreach ($exclusion as $exclusionString) {
        if (strpos($exclusionName, $exclusionString) !== false) {
            return false; // We return null
        }
    }
    return true;
}


/* TEMPLATES STARTS HERE -> */?>
//
//  BaseDocument.swift
//
//  The is the central piece of the Document oriented architecture.
//  We provide a universal implementation with conditionnal compilation
//
//  The document stores references to Bartleby's style CollectionControllers.
//  This allow to use intensively bindings and distributed data automation.
//  With the mediation of standard Bindings approach with NSArrayControler
//
//  We prefer to centralize the complexity of data handling in the document.
//  Thats why for example we implement projectBindingsArrayController.didSet with an CGD dispatching
//  We could have set the binding programmatically in the WindowController
//  But we consider for clarity that the Storyboarded Bindings Settings should be as exhaustive as possible.
//  And the potential complexity masked.
//
//  Generated by flexions
//

#if os(OSX)
import AppKit
#else
import UIKit
#endif

@objc(BaseDocument) class BaseDocument: JDocument {

    private var KVOContext: Int = 0

    // Collection Controllers
    // The initial instances are proxies
<?php
foreach ($project->entities as $entity) {
    if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $collectionControllerClassName=ucfirst($pluralizedEntity).'CollectionController';
        $collectionControllerVariableName=lcfirst($pluralizedEntity).'CollectionController';
        echoIndentCR('dynamic var '.lcfirst($pluralizedEntity).'='.$collectionControllerClassName.'()',1);
    }
}
?>

    // MARK: - OSX
#if os(OSX)


    // KVO
    // Those array controllers are Owned by their respective ViewControllers
    // Those view Controller are observed here to insure a consistent persitency


<?php
foreach ($project->entities as $entity) {
    if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        echoIndentCR('

    weak var '.$arrayControllerVariableName.': NSArrayController?{

        willSet{
            // Remove observer on previous array Controller
            '.lcfirst($arrayControllerVariableName).'?.removeObserver(self, forKeyPath: "selectionIndexes", context: &KVOContext)
        }
        didSet{
            // Setup the Array Controller in the CollectionController
            self.'.lcfirst($pluralizedEntity).'.arrayController='.lcfirst($arrayControllerVariableName).'

            // We dispatch Async to ignore the initial selectionIndex
            // that can be triggered by the GUI bindings
            // and would always propagate 0 to the state dictionary index
            dispatch_async(dispatch_get_main_queue(), { () -> Void in
                // Add observer
                self.'.lcfirst($arrayControllerVariableName).'?.addObserver(self, forKeyPath: "selectionIndexes", options: .New, context: &self.KVOContext)

                if let index=self.registryMetadata.stateDictionary[BaseDocument.kSelected'.ucfirst($entity->name).'IndexKey] as? Int{
                   if self.'.lcfirst($pluralizedEntity).'.items.count > index{
                       let selection=self.'.lcfirst($pluralizedEntity).'.items[index]
                       self.'.lcfirst($arrayControllerVariableName).'?.setSelectedObjects([selection])
                    }
                 }
            })
        }
    }
        ',0);
    }
}
?>


#endif

//Focus indexes persistency

<?php
foreach ($project->entities as $entity) {
    if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        echoIndentCR('

    static let kSelected'.ucfirst($entity->name).'IndexKey="selected'.ucfirst($entity->name).'IndexKey"

    dynamic var selected'.ucfirst($entity->name).':'.ucfirst($entity->name).'?{
        didSet{
            if let '.lcfirst($entity->name).' = selected'.ucfirst($entity->name).' {
                if let index='.lcfirst($pluralizedEntity).'.items.indexOf('.lcfirst($entity->name).'){
                    self.registryMetadata.stateDictionary[BaseDocument.kSelected'.ucfirst($entity->name).'IndexKey]=index
                }
            }
        }
    }
        ',0);
    }
}
?>




    // MARK: - DATA life cycle

    /**

    In this func you should :

    #1  Define the Schema
    #2  Register the collections

    */
    override func configureSchema(){

        // #1  Defines the Schema
        super.configureSchema()

<?php
foreach ($project->entities as $entity) {
    if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        $entityDefinition=lcfirst($entity->name).'Definition';
        echoIndentCR('

        let '.$entityDefinition.'=JCollectionMetadatum()
        '.$entityDefinition.'.proxy='.lcfirst($pluralizedEntity).'
        '.$entityDefinition.'.storage=StorageLayer.MonolithicFileStorage
        '.$entityDefinition.'.allowDistantPersistency=true
        '.$entityDefinition.'.inMemory=false
        '.$entityDefinition.'.useEncryption=Registry.encryptedMetadata
        ',0);
    }
}
?>

        // Proceed to configuration
        do{

<?php
foreach ($project->entities as $entity) {
    if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
        $pluralizedEntity=Pluralization::pluralize($entity->name);
        $arrayControllerClassName=ucfirst($pluralizedEntity).'ArrayController';
        $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
        $entityDefinition=lcfirst($entity->name).'Definition';
        echoIndentCR('try self.registryMetadata.configureSchema('.$entityDefinition.')',3);
    }
}
?>

        }catch RegistryError.DuplicatedCollectionName(let collectionName){
             print("Multiple Attempt to add the Collection named \(collectionName)")
        }catch {
            print("\(error)")
        }

        // #2 Registers the collections
        do{
            try self.registerCollections()
        }catch{
        }
    }

// MARK: - OSX specific

#if os(OSX)

// MARK: KVO

    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer<Void>) {
        guard context == &KVOContext else {
            // If the context does not match, this message
            // must be intended for our superclass.
            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
            return
        }

    // We prefer to centralize the KVO for selection indexes at the top level
    if let keyPath = keyPath, object = object {

    <?php
    foreach ($project->entities as $entity) {
        if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
            $pluralizedEntity=Pluralization::pluralize($entity->name);
            $collectionControllerClassName=ucfirst($pluralizedEntity).'CollectionController';
            $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
            echoIndentCR('

         if keyPath=="selectionIndexes" && self.'.$arrayControllerVariableName.' == object as? NSArrayController {
            if let '.lcfirst($entity->name).'=self.'.$arrayControllerVariableName.'?.selectedObjects.first as? '.ucfirst($entity->name).'{
                print("KVO Selected \('.lcfirst($entity->name).')")
                self.selected'.ucfirst($entity->name).'='.lcfirst($entity->name).'
                return
            }
        }

        ',0);
        }
    }
    ?>


    }

    }

    // MARK:  Delete currently selected items
    <?php
    echoIndentCR('',0);
    foreach ($project->entities as $entity) {
        if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
            $pluralizedEntity=Pluralization::pluralize($entity->name);
            $collectionControllerClassName=ucfirst($pluralizedEntity).'CollectionController';
            $arrayControllerVariableName=lcfirst($pluralizedEntity).'ArrayController';
            echoIndentCR('
    func deleteSelected'.ucfirst($entity->name).'() {
        // We use the collectionController to gain direct support of Undomanager
        if self.'.$arrayControllerVariableName.'?.arrangedObjects.count>0 {
            if let index=self.'.$arrayControllerVariableName.'?.selectionIndexes.firstIndex {
                self.'.lcfirst($pluralizedEntity).'.removeObjectFromItemsAtIndex(index)
            }
        }
    }

        ',0);
        }
    }
    ?>

    #else


    #endif


    // MARK: - Actions

    func synchronize() {
        // YOU SHOULD IMPLEMENT MAY BE SYNCHRONISATION
    }


    <?php
    echoIndentCR('',0);
    foreach ($project->entities as $entity) {
        if (_actionsShouldBeSupportedForEntity($project,$entity,$excludeActionsWith)){
            $pluralizedEntity=Pluralization::pluralize($entity->name);
            $collectionControllerClassName=ucfirst($pluralizedEntity).'CollectionController';

            echoIndentCR('
  func new'.ucfirst($entity->name).'()->(){
    // You should override and provide your own default values
    // And add it to the relevent dynamic collectionController
    let '.lcfirst($entity->name).'='.ucfirst($entity->name).'()
    self.'.lcfirst($pluralizedEntity).'.add('.lcfirst($entity->name).')
  }


        ',0);
        }
    }
    ?>
}